#!/usr/bin/env python

# Copyright (c) 2018, Rensselaer Polytechnic Institute, Wason Technology LLC
# All rights reserved.
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
# 
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of the Rensselaer Polytechnic Institute, nor Wason 
#       Technology LLC, nor the names of its contributors may be used to 
#       endorse or promote products derived from this software without 
#       specific prior written permission.
# 
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE


from geometry_msgs.msg import Twist
import rospy
import general_robotics_toolbox as rox
from general_robotics_toolbox import urdf
import numpy as np
import time
from rpi_abb_irc5 import EGM
from sensor_msgs.msg import Joy, JointState
from follow_joint_trajectory_action_adapter import FollowJointTrajectoryActionAdapter

cmd_vel = np.zeros(6)
joint_cmd_vel = np.zeros(6)
trajectory_vel = 0
teleop_mode = 0

def joy_teleop_callback(data):
    cmd_vel[0] = data.angular.x
    cmd_vel[1] = data.angular.y
    cmd_vel[2] = data.angular.z
    cmd_vel[3] = data.linear.x
    cmd_vel[4] = data.linear.y
    cmd_vel[5] = data.linear.z
    
def joy_callback(data):
    global trajectory_vel
    global teleop_mode
    global joint_cmd_vel
    

    if data.buttons[0] != 0:
        trajectory_vel = 0.25 * data.axes[1]
        teleop_mode = 3 
    elif data.buttons[1] != 0:
        trajectory_vel = data.axes[1]
        teleop_mode = 3
    elif data.buttons[2] != 0:
        trajectory_vel = 0.25
        teleop_mode = 3
    elif data.buttons[3] != 0:
        trajectory_vel = 1
        teleop_mode = 3
    elif data.buttons[4] != 0:
        joint_cmd_vel = np.array([data.axes[0], data.axes[1], data.axes[4], \
                                  data.axes[6], data.axes[7], data.axes[3]])*np.deg2rad(5)
        teleop_mode = 1
    elif data.buttons[5] != 0:
        teleop_mode = 2
    else:
        trajectory_vel = 0
        teleop_mode = 0

def fill_joint_state_msg(joint_angles):
    js = JointState()        
    js.header.stamp = rospy.Time.now()
    js.name = ['joint_1', 'joint_2', 'joint_3', 'joint_4', 'joint_5', 'joint_6']      
    js.position = joint_angles  
    js.velocity = [0,0,0,0,0,0]
    js.effort = [0,0,0,0,0,0]
    return js

def main():
    
    ts = 4e-3
    max_joint_vel = np.deg2rad(10)*np.ones(6)
    
    #robot = urdf.robot_from_xacro_file('urdf/irb6640_180_255.xacro',\
    #                                  package='rpi_abb_irb6640_180_255_support')
    
    robot = urdf.robot_from_parameter_server()
    
    rospy.init_node('test_egm_teleop')
    
    rospy.Subscriber("cmd_vel", Twist, joy_teleop_callback)
    rospy.Subscriber("joy", Joy, joy_callback)
    
    egm_joint_state_pub = rospy.Publisher("abb_irc5_egm/joint_states", JointState, queue_size=10)
    egm_joint_command_pub = rospy.Publisher("abb_irc5_egm/joint_commands", JointState, queue_size=10)
    
    egm = EGM()
    
    command_joints = None
    current_joints = np.zeros(6)
    
    trajectory = FollowJointTrajectoryActionAdapter()
    
    rate = rospy.Rate(250)
    
    try:
        while True:
            
            res, state = egm.receive_from_robot(0.25)
            if not res:
                command_joints = None                
            elif not state.motors_on or not state.rapid_running:
                command_joints = None                
            else:
                current_joints[:] = np.array(state.joint_angles)
                
                if command_joints is None:
                    command_joints=np.array(current_joints)
                          
                J = rox.robotjacobian(robot, current_joints)
                
                trajectory.current_joint_angles = current_joints
                                
                if teleop_mode == 3:
                    res, command_joints1 = trajectory.increment_trajectory_time(ts * trajectory_vel)
                    if res:            
                        command_joints = command_joints1
                elif teleop_mode == 2:
                    cmd_joint_vel = np.linalg.pinv(J).dot(cmd_vel)
                    cmd_joint_vel = np.clip(cmd_joint_vel, -max_joint_vel, max_joint_vel)
                    command_joints = command_joints + cmd_joint_vel.dot(ts)
                elif teleop_mode == 1:
                    command_joints = command_joints + joint_cmd_vel.dot(ts)
                               
                egm.send_to_robot(command_joints)
                
                egm_joint_state_pub.publish(fill_joint_state_msg(current_joints))
                egm_joint_command_pub.publish(fill_joint_state_msg(command_joints))
                
            rate.sleep()
    except KeyboardInterrupt:
        pass                        

if __name__ == '__main__':
    main()
